

# Syntax Analysis

This chapter is devoted to parsing methods that are typically used in compilers. We first present the basic concepts , then techniques suitable for hand implemen­tation, and finally algorithms that have been used in automated tools. Since programs may contain syntactic errors, we discuss extensions of the parsing methods for recovery from common errors.

By design, every programming language has precise rules that prescribe the syntactic structure of well-formed programs. In C, for example, a program is made up of functions, a function out of declarations and statements, a statement out of expressions, and so on. 

The syntax of programming language constructs can be specified by context-free grammars or BNF (Backus-Naur Form) nota­fition, introduced in Section 2.2 . Grammars offer significant benefits for both language designers and compiler writers.

 - A grammar gives a precise, yet easy-to-understand, syntactic specification of a programming language.
 - From certain classes of grammars, we can construct automatically an efficient parser that determines the syntactic structure of a source program. 
 	- As a side benefit, the parser-construction process can reveal syntactic ambiguities and trouble spots that might have slipped through the initial design phase of a language.
 - The structure imparted to a language by a properly designed grammar is useful for translating source programs into correct object code and for detecting errors.
 - A grammar allows a language to be evolved or developed iteratively, by adding new constructs to perform new tasks. 
 	- These new constructs can be integrated more easily into an implementation that follows the gram­matical structure of the language.


---

## 4.1 Introduction

In this section, we examine the way the parser fits into a typical compiler. We then look at typical grammars for arithmetic expressions. Grammars for ex­pressions suffice for illustrating the essence of parsing, since parsing techniques for expressions carry over to most programming constructs. This section ends with a discussion of error handling, since the parser must respond gracefully to finding that its input cannot be generated by its grammar.

---

### 4.1.1 The Role of the Parser

In our compiler model, the parser obtains a string of tokens from the lexical analyzer,  and verifies that the string of token names can be generated by the grammar for the source language. 

We expect the parser to report any syntax errors in an intelligible fashion and to recover from commonly occurring errors to continue processing the remainder of the program. 

Conceptually, for well-formed programs, the parser constructs a parse tree and passes it to the rest of the compiler for further processing. In fact, the parse tree need not be constructed explicitly, since checking and translation actions can be interspersed with parsing, as we shall see. Thus, the parser and the rest of the front end could well be implemented by a single module.

![](https://raw.githubusercontent.com/mebusy/notes/master/imgs/Compiler_F4.1png.png)

There are three general types of parsers for grammars: 

 - universal, 
	- such as the Cocke-Younger-Kasami algorithm and Earley's algorithm
	- too inefficient to use in production compilers.
 - top-down, 
	- commonly used
	- build parse trees from the top (root) to the bottom (leaves)
	- the input to the parser is scanned from left to right, one symbol at a time.
 - and bottom-up. 
	- commonly used
	- build parse trees start from the leaves and work their way up to the root
	- the input to the parser is scanned from left to right, one symbol at a time.

The most efficient top-down and bottom-up methods work only for sub­classes of grammars, but several of these classes, particularly, LL and LR gram­mars, are expressive enough to describe most of the syntactic constructs in modern programming languages. 

> LL : Left to Right, Leftmost derivation
> LR : Left to Right, Rightmost derivation

 - Parsers implemented by hand often use LL grammars; 
 	- for example, the predictive-parsing approach of Section 2.4.2 works for LL grammars.  
 - Parsers for the larger class of LR grammars are usually constructed using automated tools.

In this chapter, we assume that the output of the parser is some represent­ action of the parse tree for the stream of tokens that comes from the lexical analyzer. In practice, there are a number of tasks that might be conducted during parsing, such as 

 - collecting information about various tokens into the symbol table, 
 - performing type checking and other kinds of semantic analysis, 
 - and generating intermediate code. 

We have lumped all of these activities into the "rest of the front end" box in Fig. 4.1. These activities will be covered in detail in subsequent chapters.

---

### 4.1.2 Representative Grammars

Some of the grammars that will be examined in this chapter are presented here for ease of reference. 

Constructs that begin with keywords like **while** or **int**, are relatively easy to parse, because the keyword guides the choice of the grammar production that must be applied to match the input. We therefore concentrate on expressions, which present more of challenge, because of the associativity and precedence of operators.

Associativity and precedence are captured in the following grammar, which is similar to ones used in Chapter 2 for describing expressions, terms, and factors. *E* represents expressions consisting of terms separated by + signs, *T* represents terms consisting of factors separated by \* signs, and *F* represents factors that can be either parenthesized expressions or identifiers:

```
E → E + T | T
T → T * F | F 	(4.1) 
F → ( E ) | id
```

Expression grammar (4.1) belongs to the class of LR grammars that are suitable for bottom-up parsing. This grammar can be adapted to handle additional operators and additional levels of precedence. However, it cannot be used for top-down parsing because it is left recursive.

> left recursive 只能使用 bottom-up parsing

The following non-left-recursive variant of the expression grammar (4.1) will be used for top-down parsing:

```
E  → T E'
E' → + T E' | ε
T  → F T'			(4.2)
T' → * F T' | ε
F  → ( E ) | id  
```

The following grammar treats + and * alike, so it is useful for illustrating techniques for handling ambiguities during parsing:

```
E → E + E | E * E | ( E ) | id 		(4.3)
```

Here, E represents expressions of all types. Grammar (4.3) permits more than one parse tree for expressions like a + b \* c.


### 4.1.3 Syntax Error Handling




